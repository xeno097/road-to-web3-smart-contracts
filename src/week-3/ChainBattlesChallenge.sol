// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol";
import "@openzeppelin/contracts/utils/Counters.sol";
import "@openzeppelin/contracts/utils/Strings.sol";
import "@openzeppelin/contracts/utils/Base64.sol";

error NonExistentCharacter();
error Unauthorized();
error MaxedOutCharacter();

contract ChainBattlesChallenge is ERC721URIStorage {
    using Strings for uint256;
    using Counters for Counters.Counter;

    Counters.Counter private _tokenId;

    enum CharClass {
        Scout,
        Warrior
    }

    struct CharStats {
        uint256 level;
        uint256 speed;
        uint256 strength;
        uint256 life;
        CharClass class;
    }

    mapping(uint256 => CharStats) private tokenIdToCharStats;

    constructor() ERC721("Chain Battles", "Xeno097CBTLS") {}

    /// @dev Mints a new NFT and creates on chain metadata.
    function mint() public {
        uint256 tokenId = _tokenId.current();
        _tokenId.increment();

        _safeMint(msg.sender, tokenId);

        tokenIdToCharStats[tokenId] = CharStats({level: 0, speed: 1, strength: 1, life: 5, class: _getCharClass()});

        _setTokenURI(tokenId, _buildTokenURI(tokenId));
    }

    /// @dev Builds the NFT metadata.
    function _buildTokenURI(uint256 tokenId) private view returns (string memory) {
        bytes memory dataURI = abi.encodePacked(
            '"{name": "Chain Battles #',
            tokenId.toString(),
            '",',
            '"description": "Battles on chain",',
            '"image": "',
            _buildNftImage(tokenId),
            '"}'
        );

        return string(abi.encodePacked("data:application/json;base64,", Base64.encode(dataURI)));
    }

    /// @dev Generates the NFT image and encodes it in base64 format.
    function _buildNftImage(uint256 tokenId) private view returns (string memory) {
        CharStats storage stats = tokenIdToCharStats[tokenId];

        // Black magic to avoid stack too deep on compilation
        string memory svgPart1 = string(
            abi.encodePacked(
                '<svg xmlns="http://www.w3.org/2000/svg" preserveAspectRatio="xMinYMin meet" viewBox="0 0 350 350"> <style>.base { fill: white; font-family: serif; font-size: 14px; }</style> <rect width="100%" height="100%" fill="black" /> <text x="50%" y="40%" class="base" dominant-baseline="middle" text-anchor="middle"> Class: ',
                _charClassToString(stats.class),
                '</text> <text x="50%" y="50%" class="base" dominant-baseline="middle" text-anchor="middle"> Levels: ',
                stats.level.toString(),
                '</text> <text x="50%" y="60%" class="base" dominant-baseline="middle" text-anchor="middle"> Life: ',
                stats.life.toString(),
                '</text> <text x="50%" y="70%" class="base" dominant-baseline="middle" text-anchor="middle"> Speed: ',
                stats.speed.toString()
            )
        );

        string memory svgPart2 = string(
            abi.encodePacked(
                '</text> <text x="50%" y="80%" class="base" dominant-baseline="middle" text-anchor="middle"> Strength: ',
                stats.strength.toString(),
                "</text> </svg>"
            )
        );
        // End of black magic

        return string(
            abi.encodePacked("data:image/svg+xml;base64,", Base64.encode(bytes(string.concat(svgPart1, svgPart2))))
        );
    }

    /// @dev Converts a CharClass value to string.
    function _charClassToString(CharClass charClass) private pure returns (string memory) {
        if (charClass == CharClass.Scout) {
            return "Scout";
        }

        return "Warrior";
    }

    /// @dev Pseudo-randomly selects a class for a new character.
    function _getCharClass() private view returns (CharClass) {
        uint256 number = _generatePseudoRandomNumber(100);

        if (number % 2 == 0) {
            return CharClass.Scout;
        }

        return CharClass.Warrior;
    }

    /// @dev Generates a pseudo-random number between 0 and number.
    /// Consider using another source of randomnes like Chainlink VRF as
    /// the random number generated by this function can be predicted.
    function _generatePseudoRandomNumber(uint256 number) private view returns (uint256) {
        return uint256(keccak256(abi.encodePacked(block.timestamp, block.difficulty, msg.sender))) % number;
    }

    /// @dev Upgrades a character using pseudo-random values.
    function train(uint256 tokenId) public {
        if (!_exists(tokenId)) {
            revert NonExistentCharacter();
        }

        if (ownerOf(tokenId) != msg.sender) {
            revert Unauthorized();
        }

        CharStats storage currentStats = tokenIdToCharStats[tokenId];

        if (currentStats.level == 100) {
            revert MaxedOutCharacter();
        }

        currentStats.level++;
        currentStats.life += _generatePseudoRandomNumber(5);
        currentStats.speed += _generatePseudoRandomNumber(3);
        currentStats.strength += _generatePseudoRandomNumber(4);

        _setTokenURI(tokenId, _buildTokenURI(tokenId));
    }

    /// @dev Returns the stats for an existing character.
    function getCharStats(uint256 tokenId) public view returns (CharStats memory) {
        if (!_exists(tokenId)) {
            revert NonExistentCharacter();
        }

        return tokenIdToCharStats[tokenId];
    }
}
